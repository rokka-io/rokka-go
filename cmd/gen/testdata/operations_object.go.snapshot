package rokka

// Code generated by go generate; DO NOT EDIT.
// This file was generated at 2018-02-09 09:30:44.739516 +0100 CET m=+0.007586753

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

// Operation is an interface all operation structs implement.
type Operation interface {
	// Name returns the operation's name known by the API.
	Name() string
	// Validate checks if required properties are set.
	// Otherwise it returns false with an error indicating the missing property.
	Validate() (bool, error)
	// toURLPath generates a part of the URL used for dynamic rendering of a stack.
	toURLPath() string
}

type rawStack struct {
	Name    string          `json:"name"`
	Options json.RawMessage `json:"options"`
}

// Operations is a slice of Operation implementing json.Unmarshaler and json.Marshaler in order to create
// the correct operation types for JSON.
type Operations []Operation

// UnmarshalJSON implements json.Unmarshaler.
func (o *Operations) UnmarshalJSON(data []byte) error {
	ops := make([]rawStack, 0)
	if err := json.Unmarshal(data, &ops); err != nil {
		return err
	}
	for _, v := range ops {
		op, err := NewOperationByName(v.Name)
		if err != nil {
			return err
		}
		*o = append(*o, op.(Operation))
		if err := json.Unmarshal(v.Options, op); err != nil {
			// BUG(mweibel): We continue here when such an error is reached because rokka sometimes (legacy reasons)
			//               has options on an operation which are not of the correct type. Should we write something to stdout? also not nice though..
			continue
		}
	}
	return nil
}

// MarshalJSON implements json.Marshaler
func (o Operations) MarshalJSON() ([]byte, error) {
	ops := make([]map[string]interface{}, len(o))
	for i, v := range o {
		ops[i] = make(map[string]interface{})
		ops[i]["name"] = v.Name()
		ops[i]["options"] = v
	}

	return json.Marshal(ops)
}

var errOperationNotImplemented = errors.New("Operation not implemented")

// NewOperationByName creates a struct of the respective type based on the name given.
func NewOperationByName(name string) (Operation, error) {
	switch name {
	case "grayscale":
		return new(GrayscaleOperation), nil

	case "resize":
		return new(ResizeOperation), nil

	case "rotate":
		return new(RotateOperation), nil

	}
	return nil, errOperationNotImplemented
}

// GrayscaleOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type GrayscaleOperation struct {
}

// Name implements rokka.Operation.Name
func (o GrayscaleOperation) Name() string { return "grayscale" }

// Validate implements rokka.Operation.Validate.
func (o GrayscaleOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o GrayscaleOperation) toURLPath() string {
	options := make([]string, 0)

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// ResizeOperation is an auto-generated Operation as specified by the rokka API.
// Calling .Validate() will return false if required properties are missing.
//
// See: https://rokka.io/documentation/references/operations.html
type ResizeOperation struct {
	Height     *int    `json:"height,omitempty"`
	Mode       *string `json:"mode,omitempty"`
	Upscale    *bool   `json:"upscale,omitempty"`
	UpscaleDpr *bool   `json:"upscale_dpr,omitempty"`
	Width      *int    `json:"width,omitempty"`
}

// Name implements rokka.Operation.Name
func (o ResizeOperation) Name() string { return "resize" }

// Validate implements rokka.Operation.Validate.
func (o ResizeOperation) Validate() (bool, error) {
	valid := false
	if o.Width != nil {
		valid = true
	}
	if o.Height != nil {
		valid = true
	}
	if !valid {
		return false, errors.New("one of \"[width height]\" is required")
	}
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o ResizeOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Height != nil {
		options = append(options, fmt.Sprintf("%s-%v", "height", *o.Height))
	}
	if o.Mode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "mode", *o.Mode))
	}
	if o.Upscale != nil {
		options = append(options, fmt.Sprintf("%s-%v", "upscale", *o.Upscale))
	}
	if o.UpscaleDpr != nil {
		options = append(options, fmt.Sprintf("%s-%v", "upscale_dpr", *o.UpscaleDpr))
	}
	if o.Width != nil {
		options = append(options, fmt.Sprintf("%s-%v", "width", *o.Width))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// RotateOperation is an auto-generated Operation as specified by the rokka API.
// Calling .Validate() will return false if required properties are missing.
//
// See: https://rokka.io/documentation/references/operations.html
type RotateOperation struct {
	Angle             *float64 `json:"angle,omitempty"`
	BackgroundColor   *string  `json:"background_color,omitempty"`
	BackgroundOpacity *float64 `json:"background_opacity,omitempty"`
}

// Name implements rokka.Operation.Name
func (o RotateOperation) Name() string { return "rotate" }

// Validate implements rokka.Operation.Validate.
func (o RotateOperation) Validate() (bool, error) {
	if o.Angle == nil {
		return false, errors.New("option \"Angle\" is required")
	}
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o RotateOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Angle != nil {
		options = append(options, fmt.Sprintf("%s-%v", "angle", *o.Angle))
	}
	if o.BackgroundColor != nil {
		options = append(options, fmt.Sprintf("%s-%v", "background_color", *o.BackgroundColor))
	}
	if o.BackgroundOpacity != nil {
		options = append(options, fmt.Sprintf("%s-%v", "background_opacity", *o.BackgroundOpacity))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}
