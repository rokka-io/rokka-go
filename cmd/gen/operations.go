// This program generates rokka/operations_objects.go
package main

import (
	"bytes"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/rokka-io/rokka-go/rokka"
)

type operationProperty struct {
	Name string
	Type string
}

type operation struct {
	Name       string
	Properties []operationProperty
	Required   []string
	OneOf      []string
}

var typeMap = map[string]string{
	"integer": "int",
	"boolean": "bool",
	"string":  "string",
	"number":  "float64",
}

func toStringSlice(list []interface{}) []string {
	slice := make([]string, len(list))
	for i, v := range list {
		slice[i] = v.(string)
	}
	return slice
}

func main() {
	c := rokka.NewClient(&rokka.Config{})

	res, err := c.GetOperations()
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create("operations_objects.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	operations := make([]operation, 0)
	for name, value := range res {
		properties := make([]operationProperty, 0)
		if propertiesMap, ok := value["properties"].(map[string]interface{}); ok {
			for propName, propValue := range propertiesMap {
				propValueMap := propValue.(map[string]interface{})
				p := operationProperty{
					propName,
					typeMap[propValueMap["type"].(string)],
				}
				properties = append(properties, p)
			}
		}
		var required, oneOf []string
		if list, ok := value["required"]; ok {
			required = toStringSlice(list.([]interface{}))
		}
		if list, ok := value["oneOf"]; ok {
			oneOf = toStringSlice(list.([]interface{}))
		}
		o := operation{
			name,
			properties,
			required,
			oneOf,
		}
		operations = append(operations, o)
	}

	var b bytes.Buffer
	err = packageTemplate.Execute(&b, struct {
		Timestamp  time.Time
		Operations []operation
	}{
		Timestamp:  time.Now(),
		Operations: operations,
	})
	if err != nil {
		log.Fatal(err)
	}
	src, err := format.Source(b.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		os.Exit(1)
	}
	f.Write(src)
}

var funcMap = template.FuncMap{
	"title": strings.Title,
}

var packageTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}
package rokka

import (
	"errors"
	"fmt"
	"reflect"
)

{{- range .Operations }}
	// {{ title .Name }}Operation is an auto-generated operation object specified by the rokka API.
	{{- if (or .OneOf .Required) }}
	// Missing required properties are treated as errors.
	{{- end }}
	//
	// See: https://rokka.io/documentation/references/operations.html
	func {{ title .Name }}Operation(options map[string]interface{}) (map[string]interface{}, error) {
		{{- range .Required }}
			if _ ,ok := options["{{ . }}"]; !ok {
				return nil, errors.New("option \"{{ . }}\" is required")
			}
		{{- end}}
		{{- if .OneOf }}
		valid := false
		{{- range .OneOf }}
			if _ ,ok := options["{{ . }}"]; ok {
				valid = true
			}
		{{- end}}
		if !valid {
			return nil, errors.New("one of \"{{ .OneOf }}\" is required")
		}
		{{- end}}
		{{- if .Properties }}
		allowed := map[string]interface{}{
			{{ range .Properties -}}
				"{{ .Name }}": "{{ .Type }}",
			{{ end }}
		}
		for k, v := range options {
			t, ok := allowed[k]
			if !ok {
				return nil, fmt.Errorf("unknown option \"%s\"", k)
			}
			if reflect.TypeOf(v) != t {
				return nil, fmt.Errorf("invalid type for option \"%s\"", k)
			}
		}
		{{- end}}
		return options, nil
	}
{{- end }}
`))
