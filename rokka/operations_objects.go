package rokka

// Code generated by go generate; DO NOT EDIT.
// This file was generated at 2019-04-17 09:27:46.586645 +0200 CEST m=+0.238452251

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

// Operation is an interface all operation structs implement.
type Operation interface {
	// Name returns the operation's name known by the API.
	Name() string
	// MarshalJSON() implements json.Marshaler
	MarshalJSON() ([]byte, error)
	// UnmarshalExpressions sets the expressions for an operation
	UnmarshalExpressions(json.RawMessage) error
	// Validate checks if required properties are set.
	// Otherwise it returns false with an error indicating the missing property.
	Validate() (bool, error)
	// toURLPath generates a part of the URL used for dynamic rendering of a stack.
	toURLPath() string
}

type rawStack struct {
	Name        string          `json:"name"`
	Options     json.RawMessage `json:"options"`
	Expressions json.RawMessage `json:"expressions"`
}

// Operations is a slice of Operation implementing json.Unmarshaler and json.Marshaler in order to create
// the correct operation types for JSON.
type Operations []Operation

// UnmarshalJSON implements json.Unmarshaler.
func (o *Operations) UnmarshalJSON(data []byte) error {
	ops := make([]rawStack, 0)
	if err := json.Unmarshal(data, &ops); err != nil {
		return err
	}
	for _, v := range ops {
		op, err := NewOperationByName(v.Name)
		if err != nil {
			return err
		}
		*o = append(*o, op.(Operation))
		if err := json.Unmarshal(v.Options, op); err != nil {
			// BUG(mweibel): We continue here when such an error is reached because rokka sometimes (legacy reasons)
			//               has options on an operation which are not of the correct type. Should we write something to stdout? also not nice though..
			continue
		}
		if err := op.UnmarshalExpressions(v.Expressions); err != nil {
			return err
		}
	}
	return nil
}

var errOperationNotImplemented = errors.New("Operation not implemented")

// NewOperationByName creates a struct of the respective type based on the name given.
func NewOperationByName(name string) (Operation, error) {
	switch name {
	case "addframes":
		return new(AddframesOperation), nil

	case "alpha":
		return new(AlphaOperation), nil

	case "autorotate":
		return new(AutorotateOperation), nil

	case "blur":
		return new(BlurOperation), nil

	case "composition":
		return new(CompositionOperation), nil

	case "crop":
		return new(CropOperation), nil

	case "dropshadow":
		return new(DropshadowOperation), nil

	case "glitch":
		return new(GlitchOperation), nil

	case "grayscale":
		return new(GrayscaleOperation), nil

	case "modulate":
		return new(ModulateOperation), nil

	case "noop":
		return new(NoopOperation), nil

	case "primitive":
		return new(PrimitiveOperation), nil

	case "resize":
		return new(ResizeOperation), nil

	case "rotate":
		return new(RotateOperation), nil

	case "sepia":
		return new(SepiaOperation), nil

	case "trim":
		return new(TrimOperation), nil

	}
	return nil, errOperationNotImplemented
}

// AddframesOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type AddframesOperation struct {
	Delay   *float64 `json:"delay,omitempty"`
	Enabled *bool    `json:"enabled,omitempty"`
	Frames  *string  `json:"frames,omitempty"`

	Expressions struct {
		Delay   *string `json:"delay,omitempty"`
		Enabled *string `json:"enabled,omitempty"`
		Frames  *string `json:"frames,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o AddframesOperation) Name() string { return "addframes" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o AddframesOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Delay != nil {
		opts["delay"] = o.Delay
	}
	if o.Expressions.Delay != nil {
		exprs["delay"] = o.Expressions.Delay
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Frames != nil {
		opts["frames"] = o.Frames
	}
	if o.Expressions.Frames != nil {
		exprs["frames"] = o.Expressions.Frames
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *AddframesOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o AddframesOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o AddframesOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Delay != nil {
		options = append(options, fmt.Sprintf("%s-%v", "delay", *o.Delay))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Frames != nil {
		options = append(options, fmt.Sprintf("%s-%v", "frames", *o.Frames))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// AlphaOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type AlphaOperation struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Mode    *string `json:"mode,omitempty"`
	Opacity *int    `json:"opacity,omitempty"`

	Expressions struct {
		Enabled *string `json:"enabled,omitempty"`
		Mode    *string `json:"mode,omitempty"`
		Opacity *string `json:"opacity,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o AlphaOperation) Name() string { return "alpha" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o AlphaOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Mode != nil {
		opts["mode"] = o.Mode
	}
	if o.Expressions.Mode != nil {
		exprs["mode"] = o.Expressions.Mode
	}
	if o.Opacity != nil {
		opts["opacity"] = o.Opacity
	}
	if o.Expressions.Opacity != nil {
		exprs["opacity"] = o.Expressions.Opacity
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *AlphaOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o AlphaOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o AlphaOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Mode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "mode", *o.Mode))
	}
	if o.Opacity != nil {
		options = append(options, fmt.Sprintf("%s-%v", "opacity", *o.Opacity))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// AutorotateOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type AutorotateOperation struct {
	Enabled           *bool   `json:"enabled,omitempty"`
	Height            *int    `json:"height,omitempty"`
	RotationDirection *string `json:"rotation_direction,omitempty"`
	Width             *int    `json:"width,omitempty"`

	Expressions struct {
		Enabled           *string `json:"enabled,omitempty"`
		Height            *string `json:"height,omitempty"`
		RotationDirection *string `json:"rotation_direction,omitempty"`
		Width             *string `json:"width,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o AutorotateOperation) Name() string { return "autorotate" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o AutorotateOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Height != nil {
		opts["height"] = o.Height
	}
	if o.Expressions.Height != nil {
		exprs["height"] = o.Expressions.Height
	}
	if o.RotationDirection != nil {
		opts["rotation_direction"] = o.RotationDirection
	}
	if o.Expressions.RotationDirection != nil {
		exprs["rotation_direction"] = o.Expressions.RotationDirection
	}
	if o.Width != nil {
		opts["width"] = o.Width
	}
	if o.Expressions.Width != nil {
		exprs["width"] = o.Expressions.Width
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *AutorotateOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o AutorotateOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o AutorotateOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Height != nil {
		options = append(options, fmt.Sprintf("%s-%v", "height", *o.Height))
	}
	if o.RotationDirection != nil {
		options = append(options, fmt.Sprintf("%s-%v", "rotation_direction", *o.RotationDirection))
	}
	if o.Width != nil {
		options = append(options, fmt.Sprintf("%s-%v", "width", *o.Width))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// BlurOperation is an auto-generated Operation as specified by the rokka API.
// Calling .Validate() will return false if required properties are missing.
//
// See: https://rokka.io/documentation/references/operations.html
type BlurOperation struct {
	Enabled *bool    `json:"enabled,omitempty"`
	Sigma   *float64 `json:"sigma,omitempty"`

	Expressions struct {
		Enabled *string `json:"enabled,omitempty"`
		Sigma   *string `json:"sigma,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o BlurOperation) Name() string { return "blur" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o BlurOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Sigma != nil {
		opts["sigma"] = o.Sigma
	}
	if o.Expressions.Sigma != nil {
		exprs["sigma"] = o.Expressions.Sigma
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *BlurOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o BlurOperation) Validate() (bool, error) {
	if o.Sigma == nil {
		return false, errors.New("option \"Sigma\" is required")
	}
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o BlurOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Sigma != nil {
		options = append(options, fmt.Sprintf("%s-%v", "sigma", *o.Sigma))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// CompositionOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type CompositionOperation struct {
	Anchor           *string `json:"anchor,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty"`
	Height           *int    `json:"height,omitempty"`
	Mode             *string `json:"mode,omitempty"`
	ResizeMode       *string `json:"resize_mode,omitempty"`
	ResizeToPrimary  *bool   `json:"resize_to_primary,omitempty"`
	SecondaryColor   *string `json:"secondary_color,omitempty"`
	SecondaryImage   *string `json:"secondary_image,omitempty"`
	SecondaryOpacity *int    `json:"secondary_opacity,omitempty"`
	Width            *int    `json:"width,omitempty"`

	Expressions struct {
		Anchor           *string `json:"anchor,omitempty"`
		Enabled          *string `json:"enabled,omitempty"`
		Height           *string `json:"height,omitempty"`
		Mode             *string `json:"mode,omitempty"`
		ResizeMode       *string `json:"resize_mode,omitempty"`
		ResizeToPrimary  *string `json:"resize_to_primary,omitempty"`
		SecondaryColor   *string `json:"secondary_color,omitempty"`
		SecondaryImage   *string `json:"secondary_image,omitempty"`
		SecondaryOpacity *string `json:"secondary_opacity,omitempty"`
		Width            *string `json:"width,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o CompositionOperation) Name() string { return "composition" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o CompositionOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Anchor != nil {
		opts["anchor"] = o.Anchor
	}
	if o.Expressions.Anchor != nil {
		exprs["anchor"] = o.Expressions.Anchor
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Height != nil {
		opts["height"] = o.Height
	}
	if o.Expressions.Height != nil {
		exprs["height"] = o.Expressions.Height
	}
	if o.Mode != nil {
		opts["mode"] = o.Mode
	}
	if o.Expressions.Mode != nil {
		exprs["mode"] = o.Expressions.Mode
	}
	if o.ResizeMode != nil {
		opts["resize_mode"] = o.ResizeMode
	}
	if o.Expressions.ResizeMode != nil {
		exprs["resize_mode"] = o.Expressions.ResizeMode
	}
	if o.ResizeToPrimary != nil {
		opts["resize_to_primary"] = o.ResizeToPrimary
	}
	if o.Expressions.ResizeToPrimary != nil {
		exprs["resize_to_primary"] = o.Expressions.ResizeToPrimary
	}
	if o.SecondaryColor != nil {
		opts["secondary_color"] = o.SecondaryColor
	}
	if o.Expressions.SecondaryColor != nil {
		exprs["secondary_color"] = o.Expressions.SecondaryColor
	}
	if o.SecondaryImage != nil {
		opts["secondary_image"] = o.SecondaryImage
	}
	if o.Expressions.SecondaryImage != nil {
		exprs["secondary_image"] = o.Expressions.SecondaryImage
	}
	if o.SecondaryOpacity != nil {
		opts["secondary_opacity"] = o.SecondaryOpacity
	}
	if o.Expressions.SecondaryOpacity != nil {
		exprs["secondary_opacity"] = o.Expressions.SecondaryOpacity
	}
	if o.Width != nil {
		opts["width"] = o.Width
	}
	if o.Expressions.Width != nil {
		exprs["width"] = o.Expressions.Width
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *CompositionOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o CompositionOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o CompositionOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Anchor != nil {
		options = append(options, fmt.Sprintf("%s-%v", "anchor", *o.Anchor))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Height != nil {
		options = append(options, fmt.Sprintf("%s-%v", "height", *o.Height))
	}
	if o.Mode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "mode", *o.Mode))
	}
	if o.ResizeMode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "resize_mode", *o.ResizeMode))
	}
	if o.ResizeToPrimary != nil {
		options = append(options, fmt.Sprintf("%s-%v", "resize_to_primary", *o.ResizeToPrimary))
	}
	if o.SecondaryColor != nil {
		options = append(options, fmt.Sprintf("%s-%v", "secondary_color", *o.SecondaryColor))
	}
	if o.SecondaryImage != nil {
		options = append(options, fmt.Sprintf("%s-%v", "secondary_image", *o.SecondaryImage))
	}
	if o.SecondaryOpacity != nil {
		options = append(options, fmt.Sprintf("%s-%v", "secondary_opacity", *o.SecondaryOpacity))
	}
	if o.Width != nil {
		options = append(options, fmt.Sprintf("%s-%v", "width", *o.Width))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// CropOperation is an auto-generated Operation as specified by the rokka API.
// Calling .Validate() will return false if required properties are missing.
//
// See: https://rokka.io/documentation/references/operations.html
type CropOperation struct {
	Anchor   *string  `json:"anchor,omitempty"`
	Area     *string  `json:"area,omitempty"`
	Enabled  *bool    `json:"enabled,omitempty"`
	Fallback *string  `json:"fallback,omitempty"`
	Height   *int     `json:"height,omitempty"`
	Mode     *string  `json:"mode,omitempty"`
	Scale    *float64 `json:"scale,omitempty"`
	Width    *int     `json:"width,omitempty"`

	Expressions struct {
		Anchor   *string `json:"anchor,omitempty"`
		Area     *string `json:"area,omitempty"`
		Enabled  *string `json:"enabled,omitempty"`
		Fallback *string `json:"fallback,omitempty"`
		Height   *string `json:"height,omitempty"`
		Mode     *string `json:"mode,omitempty"`
		Scale    *string `json:"scale,omitempty"`
		Width    *string `json:"width,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o CropOperation) Name() string { return "crop" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o CropOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Anchor != nil {
		opts["anchor"] = o.Anchor
	}
	if o.Expressions.Anchor != nil {
		exprs["anchor"] = o.Expressions.Anchor
	}
	if o.Area != nil {
		opts["area"] = o.Area
	}
	if o.Expressions.Area != nil {
		exprs["area"] = o.Expressions.Area
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Fallback != nil {
		opts["fallback"] = o.Fallback
	}
	if o.Expressions.Fallback != nil {
		exprs["fallback"] = o.Expressions.Fallback
	}
	if o.Height != nil {
		opts["height"] = o.Height
	}
	if o.Expressions.Height != nil {
		exprs["height"] = o.Expressions.Height
	}
	if o.Mode != nil {
		opts["mode"] = o.Mode
	}
	if o.Expressions.Mode != nil {
		exprs["mode"] = o.Expressions.Mode
	}
	if o.Scale != nil {
		opts["scale"] = o.Scale
	}
	if o.Expressions.Scale != nil {
		exprs["scale"] = o.Expressions.Scale
	}
	if o.Width != nil {
		opts["width"] = o.Width
	}
	if o.Expressions.Width != nil {
		exprs["width"] = o.Expressions.Width
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *CropOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o CropOperation) Validate() (bool, error) {
	if o.Width == nil {
		return false, errors.New("option \"Width\" is required")
	}
	if o.Height == nil {
		return false, errors.New("option \"Height\" is required")
	}
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o CropOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Anchor != nil {
		options = append(options, fmt.Sprintf("%s-%v", "anchor", *o.Anchor))
	}
	if o.Area != nil {
		options = append(options, fmt.Sprintf("%s-%v", "area", *o.Area))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Fallback != nil {
		options = append(options, fmt.Sprintf("%s-%v", "fallback", *o.Fallback))
	}
	if o.Height != nil {
		options = append(options, fmt.Sprintf("%s-%v", "height", *o.Height))
	}
	if o.Mode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "mode", *o.Mode))
	}
	if o.Scale != nil {
		options = append(options, fmt.Sprintf("%s-%v", "scale", *o.Scale))
	}
	if o.Width != nil {
		options = append(options, fmt.Sprintf("%s-%v", "width", *o.Width))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// DropshadowOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type DropshadowOperation struct {
	BlurRadius *float64 `json:"blur_radius,omitempty"`
	Color      *string  `json:"color,omitempty"`
	Enabled    *bool    `json:"enabled,omitempty"`
	Horizontal *int     `json:"horizontal,omitempty"`
	Opacity    *int     `json:"opacity,omitempty"`
	Sigma      *float64 `json:"sigma,omitempty"`
	Vertical   *int     `json:"vertical,omitempty"`

	Expressions struct {
		BlurRadius *string `json:"blur_radius,omitempty"`
		Color      *string `json:"color,omitempty"`
		Enabled    *string `json:"enabled,omitempty"`
		Horizontal *string `json:"horizontal,omitempty"`
		Opacity    *string `json:"opacity,omitempty"`
		Sigma      *string `json:"sigma,omitempty"`
		Vertical   *string `json:"vertical,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o DropshadowOperation) Name() string { return "dropshadow" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o DropshadowOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.BlurRadius != nil {
		opts["blur_radius"] = o.BlurRadius
	}
	if o.Expressions.BlurRadius != nil {
		exprs["blur_radius"] = o.Expressions.BlurRadius
	}
	if o.Color != nil {
		opts["color"] = o.Color
	}
	if o.Expressions.Color != nil {
		exprs["color"] = o.Expressions.Color
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Horizontal != nil {
		opts["horizontal"] = o.Horizontal
	}
	if o.Expressions.Horizontal != nil {
		exprs["horizontal"] = o.Expressions.Horizontal
	}
	if o.Opacity != nil {
		opts["opacity"] = o.Opacity
	}
	if o.Expressions.Opacity != nil {
		exprs["opacity"] = o.Expressions.Opacity
	}
	if o.Sigma != nil {
		opts["sigma"] = o.Sigma
	}
	if o.Expressions.Sigma != nil {
		exprs["sigma"] = o.Expressions.Sigma
	}
	if o.Vertical != nil {
		opts["vertical"] = o.Vertical
	}
	if o.Expressions.Vertical != nil {
		exprs["vertical"] = o.Expressions.Vertical
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *DropshadowOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o DropshadowOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o DropshadowOperation) toURLPath() string {
	options := make([]string, 0)
	if o.BlurRadius != nil {
		options = append(options, fmt.Sprintf("%s-%v", "blur_radius", *o.BlurRadius))
	}
	if o.Color != nil {
		options = append(options, fmt.Sprintf("%s-%v", "color", *o.Color))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Horizontal != nil {
		options = append(options, fmt.Sprintf("%s-%v", "horizontal", *o.Horizontal))
	}
	if o.Opacity != nil {
		options = append(options, fmt.Sprintf("%s-%v", "opacity", *o.Opacity))
	}
	if o.Sigma != nil {
		options = append(options, fmt.Sprintf("%s-%v", "sigma", *o.Sigma))
	}
	if o.Vertical != nil {
		options = append(options, fmt.Sprintf("%s-%v", "vertical", *o.Vertical))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// GlitchOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type GlitchOperation struct {
	Amount  *int    `json:"amount,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Random  *string `json:"random,omitempty"`

	Expressions struct {
		Amount  *string `json:"amount,omitempty"`
		Enabled *string `json:"enabled,omitempty"`
		Random  *string `json:"random,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o GlitchOperation) Name() string { return "glitch" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o GlitchOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Amount != nil {
		opts["amount"] = o.Amount
	}
	if o.Expressions.Amount != nil {
		exprs["amount"] = o.Expressions.Amount
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Random != nil {
		opts["random"] = o.Random
	}
	if o.Expressions.Random != nil {
		exprs["random"] = o.Expressions.Random
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *GlitchOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o GlitchOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o GlitchOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Amount != nil {
		options = append(options, fmt.Sprintf("%s-%v", "amount", *o.Amount))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Random != nil {
		options = append(options, fmt.Sprintf("%s-%v", "random", *o.Random))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// GrayscaleOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type GrayscaleOperation struct {
	Enabled *bool `json:"enabled,omitempty"`

	Expressions struct {
		Enabled *string `json:"enabled,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o GrayscaleOperation) Name() string { return "grayscale" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o GrayscaleOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *GrayscaleOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o GrayscaleOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o GrayscaleOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// ModulateOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type ModulateOperation struct {
	Brightness *int  `json:"brightness,omitempty"`
	Enabled    *bool `json:"enabled,omitempty"`
	Hue        *int  `json:"hue,omitempty"`
	Saturation *int  `json:"saturation,omitempty"`

	Expressions struct {
		Brightness *string `json:"brightness,omitempty"`
		Enabled    *string `json:"enabled,omitempty"`
		Hue        *string `json:"hue,omitempty"`
		Saturation *string `json:"saturation,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o ModulateOperation) Name() string { return "modulate" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o ModulateOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Brightness != nil {
		opts["brightness"] = o.Brightness
	}
	if o.Expressions.Brightness != nil {
		exprs["brightness"] = o.Expressions.Brightness
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Hue != nil {
		opts["hue"] = o.Hue
	}
	if o.Expressions.Hue != nil {
		exprs["hue"] = o.Expressions.Hue
	}
	if o.Saturation != nil {
		opts["saturation"] = o.Saturation
	}
	if o.Expressions.Saturation != nil {
		exprs["saturation"] = o.Expressions.Saturation
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *ModulateOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o ModulateOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o ModulateOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Brightness != nil {
		options = append(options, fmt.Sprintf("%s-%v", "brightness", *o.Brightness))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Hue != nil {
		options = append(options, fmt.Sprintf("%s-%v", "hue", *o.Hue))
	}
	if o.Saturation != nil {
		options = append(options, fmt.Sprintf("%s-%v", "saturation", *o.Saturation))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// NoopOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type NoopOperation struct {
	Enabled *bool `json:"enabled,omitempty"`

	Expressions struct {
		Enabled *string `json:"enabled,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o NoopOperation) Name() string { return "noop" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o NoopOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *NoopOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o NoopOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o NoopOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// PrimitiveOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type PrimitiveOperation struct {
	Count   *int  `json:"count,omitempty"`
	Enabled *bool `json:"enabled,omitempty"`
	Mode    *int  `json:"mode,omitempty"`

	Expressions struct {
		Count   *string `json:"count,omitempty"`
		Enabled *string `json:"enabled,omitempty"`
		Mode    *string `json:"mode,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o PrimitiveOperation) Name() string { return "primitive" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o PrimitiveOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Count != nil {
		opts["count"] = o.Count
	}
	if o.Expressions.Count != nil {
		exprs["count"] = o.Expressions.Count
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Mode != nil {
		opts["mode"] = o.Mode
	}
	if o.Expressions.Mode != nil {
		exprs["mode"] = o.Expressions.Mode
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *PrimitiveOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o PrimitiveOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o PrimitiveOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Count != nil {
		options = append(options, fmt.Sprintf("%s-%v", "count", *o.Count))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Mode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "mode", *o.Mode))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// ResizeOperation is an auto-generated Operation as specified by the rokka API.
// Calling .Validate() will return false if required properties are missing.
//
// See: https://rokka.io/documentation/references/operations.html
type ResizeOperation struct {
	Enabled    *bool   `json:"enabled,omitempty"`
	Height     *int    `json:"height,omitempty"`
	Mode       *string `json:"mode,omitempty"`
	Upscale    *bool   `json:"upscale,omitempty"`
	UpscaleDpr *bool   `json:"upscale_dpr,omitempty"`
	Width      *int    `json:"width,omitempty"`

	Expressions struct {
		Enabled    *string `json:"enabled,omitempty"`
		Height     *string `json:"height,omitempty"`
		Mode       *string `json:"mode,omitempty"`
		Upscale    *string `json:"upscale,omitempty"`
		UpscaleDpr *string `json:"upscale_dpr,omitempty"`
		Width      *string `json:"width,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o ResizeOperation) Name() string { return "resize" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o ResizeOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Height != nil {
		opts["height"] = o.Height
	}
	if o.Expressions.Height != nil {
		exprs["height"] = o.Expressions.Height
	}
	if o.Mode != nil {
		opts["mode"] = o.Mode
	}
	if o.Expressions.Mode != nil {
		exprs["mode"] = o.Expressions.Mode
	}
	if o.Upscale != nil {
		opts["upscale"] = o.Upscale
	}
	if o.Expressions.Upscale != nil {
		exprs["upscale"] = o.Expressions.Upscale
	}
	if o.UpscaleDpr != nil {
		opts["upscale_dpr"] = o.UpscaleDpr
	}
	if o.Expressions.UpscaleDpr != nil {
		exprs["upscale_dpr"] = o.Expressions.UpscaleDpr
	}
	if o.Width != nil {
		opts["width"] = o.Width
	}
	if o.Expressions.Width != nil {
		exprs["width"] = o.Expressions.Width
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *ResizeOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o ResizeOperation) Validate() (bool, error) {
	valid := false
	if o.Width != nil {
		valid = true
	}
	if o.Height != nil {
		valid = true
	}
	if !valid {
		return false, errors.New("one of \"[width height]\" is required")
	}
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o ResizeOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Height != nil {
		options = append(options, fmt.Sprintf("%s-%v", "height", *o.Height))
	}
	if o.Mode != nil {
		options = append(options, fmt.Sprintf("%s-%v", "mode", *o.Mode))
	}
	if o.Upscale != nil {
		options = append(options, fmt.Sprintf("%s-%v", "upscale", *o.Upscale))
	}
	if o.UpscaleDpr != nil {
		options = append(options, fmt.Sprintf("%s-%v", "upscale_dpr", *o.UpscaleDpr))
	}
	if o.Width != nil {
		options = append(options, fmt.Sprintf("%s-%v", "width", *o.Width))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// RotateOperation is an auto-generated Operation as specified by the rokka API.
// Calling .Validate() will return false if required properties are missing.
//
// See: https://rokka.io/documentation/references/operations.html
type RotateOperation struct {
	Angle             *float64 `json:"angle,omitempty"`
	BackgroundColor   *string  `json:"background_color,omitempty"`
	BackgroundOpacity *float64 `json:"background_opacity,omitempty"`
	Enabled           *bool    `json:"enabled,omitempty"`

	Expressions struct {
		Angle             *string `json:"angle,omitempty"`
		BackgroundColor   *string `json:"background_color,omitempty"`
		BackgroundOpacity *string `json:"background_opacity,omitempty"`
		Enabled           *string `json:"enabled,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o RotateOperation) Name() string { return "rotate" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o RotateOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Angle != nil {
		opts["angle"] = o.Angle
	}
	if o.Expressions.Angle != nil {
		exprs["angle"] = o.Expressions.Angle
	}
	if o.BackgroundColor != nil {
		opts["background_color"] = o.BackgroundColor
	}
	if o.Expressions.BackgroundColor != nil {
		exprs["background_color"] = o.Expressions.BackgroundColor
	}
	if o.BackgroundOpacity != nil {
		opts["background_opacity"] = o.BackgroundOpacity
	}
	if o.Expressions.BackgroundOpacity != nil {
		exprs["background_opacity"] = o.Expressions.BackgroundOpacity
	}
	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *RotateOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o RotateOperation) Validate() (bool, error) {
	if o.Angle == nil {
		return false, errors.New("option \"Angle\" is required")
	}
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o RotateOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Angle != nil {
		options = append(options, fmt.Sprintf("%s-%v", "angle", *o.Angle))
	}
	if o.BackgroundColor != nil {
		options = append(options, fmt.Sprintf("%s-%v", "background_color", *o.BackgroundColor))
	}
	if o.BackgroundOpacity != nil {
		options = append(options, fmt.Sprintf("%s-%v", "background_opacity", *o.BackgroundOpacity))
	}
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// SepiaOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type SepiaOperation struct {
	Enabled *bool `json:"enabled,omitempty"`

	Expressions struct {
		Enabled *string `json:"enabled,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o SepiaOperation) Name() string { return "sepia" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o SepiaOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *SepiaOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o SepiaOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o SepiaOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}

// TrimOperation is an auto-generated Operation as specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
type TrimOperation struct {
	Enabled *bool    `json:"enabled,omitempty"`
	Fuzzy   *float64 `json:"fuzzy,omitempty"`

	Expressions struct {
		Enabled *string `json:"enabled,omitempty"`
		Fuzzy   *string `json:"fuzzy,omitempty"`
	} `json:"expressions,omitempty"`
}

// Name implements rokka.Operation.Name
func (o TrimOperation) Name() string { return "trim" }

// MarshalJSON() implements rokka.Operation.MarshalJSON
func (o TrimOperation) MarshalJSON() ([]byte, error) {
	data := make(map[string]interface{})
	data["name"] = o.Name()

	opts := make(map[string]interface{})
	exprs := make(map[string]interface{})

	if o.Enabled != nil {
		opts["enabled"] = o.Enabled
	}
	if o.Expressions.Enabled != nil {
		exprs["enabled"] = o.Expressions.Enabled
	}
	if o.Fuzzy != nil {
		opts["fuzzy"] = o.Fuzzy
	}
	if o.Expressions.Fuzzy != nil {
		exprs["fuzzy"] = o.Expressions.Fuzzy
	}

	if len(opts) > 0 {
		data["options"] = opts
	}
	if len(exprs) > 0 {
		data["expressions"] = exprs
	}

	return json.Marshal(data)
}

// UnmarshalExpressions implements rokka.Operation.UnmarshalExpressions and needs to write back to the struct
func (o *TrimOperation) UnmarshalExpressions(r json.RawMessage) error {
	return json.Unmarshal(r, &o.Expressions)
}

// Validate implements rokka.Operation.Validate.
func (o TrimOperation) Validate() (bool, error) {
	return true, nil
}

// toURLPath implements rokka.Operation.toURLPath.
func (o TrimOperation) toURLPath() string {
	options := make([]string, 0)
	if o.Enabled != nil {
		options = append(options, fmt.Sprintf("%s-%v", "enabled", *o.Enabled))
	}
	if o.Fuzzy != nil {
		options = append(options, fmt.Sprintf("%s-%v", "fuzzy", *o.Fuzzy))
	}

	if len(options) == 0 {
		return o.Name()
	}
	return fmt.Sprintf("%s-%s", o.Name(), strings.Join(options, "-"))
}
