// Code generated by go generate; DO NOT EDIT.
// This file was generated at 2017-12-20 10:00:38.086500242 +0100 CET m=+0.139180844
package rokka

import (
	"errors"
	"fmt"
	"reflect"
)

// AutorotateOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func AutorotateOperation(options map[string]interface{}) (map[string]interface{}, error) {
	allowed := map[string]interface{}{
		"width":              "int",
		"height":             "int",
		"rotation_direction": "string",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// NoopOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func NoopOperation(options map[string]interface{}) (map[string]interface{}, error) {
	return options, nil
}

// CompositionOperation is an auto-generated operation object specified by the rokka API.
// Missing required properties are treated as errors.
//
// See: https://rokka.io/documentation/references/operations.html
func CompositionOperation(options map[string]interface{}) (map[string]interface{}, error) {
	if _, ok := options["mode"]; !ok {
		return nil, errors.New("option \"mode\" is required")
	}
	if _, ok := options["width"]; !ok {
		return nil, errors.New("option \"width\" is required")
	}
	if _, ok := options["height"]; !ok {
		return nil, errors.New("option \"height\" is required")
	}
	allowed := map[string]interface{}{
		"mode":              "string",
		"width":             "int",
		"height":            "int",
		"anchor":            "string",
		"secondary_color":   "string",
		"secondary_opacity": "int",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// GrayscaleOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func GrayscaleOperation(options map[string]interface{}) (map[string]interface{}, error) {
	return options, nil
}

// SepiaOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func SepiaOperation(options map[string]interface{}) (map[string]interface{}, error) {
	return options, nil
}

// AlphaOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func AlphaOperation(options map[string]interface{}) (map[string]interface{}, error) {
	allowed := map[string]interface{}{
		"mode": "string",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// ResizeOperation is an auto-generated operation object specified by the rokka API.
// Missing required properties are treated as errors.
//
// See: https://rokka.io/documentation/references/operations.html
func ResizeOperation(options map[string]interface{}) (map[string]interface{}, error) {
	valid := false
	if _, ok := options["width"]; ok {
		valid = true
	}
	if _, ok := options["height"]; ok {
		valid = true
	}
	if !valid {
		return nil, errors.New("one of \"[width height]\" is required")
	}
	allowed := map[string]interface{}{
		"width":       "int",
		"height":      "int",
		"mode":        "string",
		"upscale":     "bool",
		"upscale_dpr": "bool",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// DropshadowOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func DropshadowOperation(options map[string]interface{}) (map[string]interface{}, error) {
	allowed := map[string]interface{}{
		"sigma":       "float64",
		"blur_radius": "float64",
		"color":       "string",
		"horizontal":  "int",
		"vertical":    "int",
		"opacity":     "int",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// TrimOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func TrimOperation(options map[string]interface{}) (map[string]interface{}, error) {
	allowed := map[string]interface{}{
		"fuzzy": "float64",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// CropOperation is an auto-generated operation object specified by the rokka API.
// Missing required properties are treated as errors.
//
// See: https://rokka.io/documentation/references/operations.html
func CropOperation(options map[string]interface{}) (map[string]interface{}, error) {
	if _, ok := options["width"]; !ok {
		return nil, errors.New("option \"width\" is required")
	}
	if _, ok := options["height"]; !ok {
		return nil, errors.New("option \"height\" is required")
	}
	allowed := map[string]interface{}{
		"mode":   "string",
		"scale":  "float64",
		"width":  "int",
		"height": "int",
		"anchor": "string",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// BlurOperation is an auto-generated operation object specified by the rokka API.
// Missing required properties are treated as errors.
//
// See: https://rokka.io/documentation/references/operations.html
func BlurOperation(options map[string]interface{}) (map[string]interface{}, error) {
	if _, ok := options["sigma"]; !ok {
		return nil, errors.New("option \"sigma\" is required")
	}
	allowed := map[string]interface{}{
		"sigma": "float64",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// PrimitiveOperation is an auto-generated operation object specified by the rokka API.
//
// See: https://rokka.io/documentation/references/operations.html
func PrimitiveOperation(options map[string]interface{}) (map[string]interface{}, error) {
	allowed := map[string]interface{}{
		"count": "int",
		"mode":  "int",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}

// RotateOperation is an auto-generated operation object specified by the rokka API.
// Missing required properties are treated as errors.
//
// See: https://rokka.io/documentation/references/operations.html
func RotateOperation(options map[string]interface{}) (map[string]interface{}, error) {
	if _, ok := options["angle"]; !ok {
		return nil, errors.New("option \"angle\" is required")
	}
	allowed := map[string]interface{}{
		"angle":              "float64",
		"background_color":   "string",
		"background_opacity": "float64",
	}
	for k, v := range options {
		t, ok := allowed[k]
		if !ok {
			return nil, fmt.Errorf("unknown option \"%s\"", k)
		}
		if reflect.TypeOf(v) != t {
			return nil, fmt.Errorf("invalid type for option \"%s\"", k)
		}
	}
	return options, nil
}
